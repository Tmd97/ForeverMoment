package com.forvmom.core.services;

import com.forvmom.common.dto.response.AdminAppUserResponseDto;
import com.forvmom.common.dto.response.RoleResponseDto;
import com.forvmom.common.errorhandler.CustomAuthException;
import com.forvmom.common.errorhandler.ResourceNotFoundException;
import com.forvmom.common.dto.request.UserProfileRequestDto;
import com.forvmom.core.mapper.ApplicationUserBeanMapper;
import com.forvmom.core.mapper.RoleBeanMapper;
import com.forvmom.data.dao.ApplicationUserDao;
import com.forvmom.data.dao.auth.AuthUserDao;
import com.forvmom.data.dao.auth.AuthUserRoleDao;
import com.forvmom.data.entities.ApplicationUser;
import com.forvmom.data.entities.auth.AuthUserRole;
import com.forvmom.data.entities.auth.Role;
import com.forvmom.data.dao.auth.RoleDao;
import com.forvmom.data.entities.auth.AuthUser;
import com.forvmom.security.dto.AuthResponse;
import com.forvmom.security.dto.RegisterRequestDto;
import com.forvmom.security.service.AuthService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
@Transactional
public class AdminUserService {

    private static final Logger logger = LoggerFactory.getLogger(AdminUserService.class);

    @Autowired
    private ApplicationUserDao applicationUserDao;

    @Autowired
    private AuthUserDao authUserDao;

    @Autowired
    private AuthUserRoleDao authUserRoleDao;

    @Autowired
    private AuthService authService;

    @Autowired
    private RoleDao roleDao;

    @Transactional
    public AdminAppUserResponseDto createUser(RegisterRequestDto request) {
        AuthResponse authResponse = authService.register(request);
        // fetch the application user details using the auth user id
        Optional<ApplicationUser> appUser = applicationUserDao.findByAuthUserId(authResponse.getUserId());
        if (appUser.isEmpty()) {
            throw new ResourceNotFoundException(
                    "User created but profile not found for auth id: " + authResponse.getUserId());
        }
        AdminAppUserResponseDto res = ApplicationUserBeanMapper.mapEntityToAdminDto(appUser.get());
        // do populate whatever required from auth response(afermath)
        res.setCreatedBy(authResponse.getAssignedBy());
        return res;
    }

    @Transactional(readOnly = true)
    public AdminAppUserResponseDto getAppUserById(Long id) {
        ApplicationUser appUser = applicationUserDao.findByIdWithAuthAndRoles(id)
                .orElseThrow(() -> new ResourceNotFoundException("No User exist given Id exist " + id));
        return ApplicationUserBeanMapper.mapEntityToAdminDto(appUser);
    }

    @Transactional(readOnly = true)
    public AdminAppUserResponseDto getAppUserByEmailId(String email) {
        Optional<ApplicationUser> appUser = applicationUserDao.findByEmailIgnoreCase(email);
        if (appUser.isEmpty()) {
            throw new ResourceNotFoundException("No User exist given email exist " + email);
        }
        return ApplicationUserBeanMapper.mapEntityToAdminDto(appUser.get());
    }

    @Transactional(readOnly = true)
    public List<AdminAppUserResponseDto> getAllAppUser() {
        // Use optimized query to fetch All Users + Auth + Roles
        List<ApplicationUser> applicationUsers = applicationUserDao.findAllWithAuthAndRoles();
        if (applicationUsers == null || applicationUsers.isEmpty()) {
            throw new ResourceNotFoundException("users doesn't exist");
        }
        return applicationUsers.stream()
                .map(ApplicationUserBeanMapper::mapEntityToAdminDto)
                .toList();
    }

    @Transactional
    public AdminAppUserResponseDto updateAppUser(Long userId,
            UserProfileRequestDto userDto) {
        ApplicationUser existing = applicationUserDao.findById(userId);
        if (existing == null) {
            throw new ResourceNotFoundException("No such user for given Id exist " + userId);
        }
        // map only updatable fields
        ApplicationUserBeanMapper.mapDtoToEntity(userDto, existing);

        // Handle Role Update if provided
        if (userDto.getRoleId() != null) {
            Role role = roleDao.findById(userDto.getRoleId());
            if (role == null) {
                throw new ResourceNotFoundException("User Role not exist in the System");
            }

            AuthUser authUser = existing.getAuthUser();
            // Clear existing roles and add new one
            authUser.getUserRoles().clear();
            authUser.addRole(role);
            // AuthUser updates will be cascaded if ApplicationUser -> AuthUser cascade is
            // set,
            // or we might need to save AuthUser explicitly if not.
            // ApplicationUser has @OneToOne(optional = false) private AuthUser authUser;
            // It defaults to no cascade usually unless specified.
            // Let's save AuthUser explicitly to be safe, or just rely on Transactional.
            // Since we modified the collection of AuthUser, and AuthUser is a managed
            // entity (fetched via graph in findById possibly, or via getter),
            // changes should be flushed at transaction commit.
            // However, existing ApplicationUser fetch in updateAppUser is just findById.
            // applicationUserDao.findById(userId) might not fetch AuthUser eagerly?
            // ApplicationUser.java: @OneToOne(optional = false) ... private AuthUser
            // authUser; (Default EAGER for OneToOne).
            // So AuthUser is fetched.
            // AuthUser.java: @OneToMany(mappedBy = "authUser", fetch = FetchType.LAZY,
            // cascade = CascadeType.ALL) private Set<AuthUserRole> userRoles;
            // Accessing getUserRoles() might trigger lazy load.
            // Since we are in @Transactional, it should work.
        }

        ApplicationUser res = applicationUserDao.update(existing);
        return ApplicationUserBeanMapper.mapEntityToAdminDto(res);
    }

    // TODO: we can also add soft delete functionality here instead of hard delete,
    // as per requirement
    /*
     * This method deletes the user account along with the associated authentication
     * details.
     */
    // @Transactional
    // public void deleteUserAccount(Long userId) {
    // AuthUser authUser = authUserDao.findById(userId);
    // if (authUser == null) {
    // logger.warn("Delete account failed: User not found - {}", userId);
    // throw new CustomAuthException("User not found for id: " + userId);
    // }
    // authUserDao.delete(authUser);
    // logger.info("User account deleted successfully for userId: {}", userId);
    // }

    @Transactional
    public void deleteUserProfile(Long userId) {
        ApplicationUser userProfile = applicationUserDao.findById(userId);
        if (userProfile == null) {
            logger.warn("Delete profile failed: AppUser not found - {}", userId);
            throw new CustomAuthException("AppUser not found for id: " + userId);
        }
        applicationUserDao.delete(userProfile);
        logger.info("User Profile deleted successfully for userId: {}", userId);
    }

    @Transactional
    public void deleteAccount(Long userId) {
        ApplicationUser userProfile = applicationUserDao.findById(userId);
        if (userProfile == null) {
            logger.warn("Delete Account failed: AppUser not found - {}", userId);
            throw new CustomAuthException("AppUser not found for id: " + userId);
        }
        // Soft delete the application user profile
        applicationUserDao.delete(userProfile);

        // Note: AuthUser remains active but unlinked from profile (unless cascaded).
        // If AuthUser should be disabled or deleted, logic should be added here.
        // For now, adhering to soft delete of ApplicationUser.

        logger.info("User Account (Profile) deleted successfully for userId: {}", userId);
    }

    // @Transactional
    // public List<RoleResponseDto> getUserRoles(Long userId) {
    // List<AuthUserRole> authUserRoles = authUserRoleDao.findByAuthUserId(userId);
    // if (authUserRoles == null || authUserRoles.isEmpty()) {
    // throw new ResourceNotFoundException("No roles found for user id: " + userId);
    // }
    // List<RoleResponseDto> responseDtos = authUserRoles.stream()
    // .map(authUserRole -> authUserRole.getRole())
    // .map(RoleBeanMapper::mapEntityToDto).collect(Collectors.toList());
    //
    // return responseDtos;
    // }

    @Transactional
    public List<RoleResponseDto> getRolesByAppUserId(Long appUserId) {
        ApplicationUser appUser = applicationUserDao.findByIdWithAuthAndRoles(appUserId)
                .orElseThrow(() -> new ResourceNotFoundException("No user found for id: " + appUserId));

        if (appUser.getAuthUser() == null || appUser.getAuthUser().getUserRoles() == null) {
            return List.of();
        }

        return appUser.getAuthUser().getUserRoles().stream()
                .map(AuthUserRole::getRole)
                .map(RoleBeanMapper::mapEntityToDto)
                .collect(Collectors.toList());
    }
}
